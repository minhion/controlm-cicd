name: Control-M Job Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - test
          - production
      server_name:
        description: 'Control-M Server Name (e.g., IN01, TEST_SERVER)'
        required: false
        type: string
        default: ''
      job_file:
        description: 'Specific job file to deploy (optional)'
        required: false
        type: string
      run_jobs:
        description: 'Run jobs after deployment'
        required: false
        default: false
        type: boolean

env:
  DOCKER_IMAGE: minhion/controlm-cli:22

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      target_env: ${{ steps.set-env.outputs.target_env }}
      ctm_endpoint: ${{ steps.set-env.outputs.ctm_endpoint }}
      ctm_env_name: ${{ steps.set-env.outputs.ctm_env_name }}
      ctm_server_name: ${{ steps.set-env.outputs.ctm_server_name }}
      descriptor_file: ${{ steps.set-env.outputs.descriptor_file }}
    steps:
      - name: Determine target environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TARGET_ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TARGET_ENV="test"
          else
            TARGET_ENV="development"
          fi
          
          echo "target_env=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "Target environment: $TARGET_ENV"
          
          # Set environment-specific variables including server names
          case $TARGET_ENV in
            "production")
              echo "ctm_endpoint=https://se-prod-aapi.us1.controlm.com/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=prod" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to IN01
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="IN01"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-production.json" >> $GITHUB_OUTPUT
              ;;
            "test")
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=test" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to TEST_SERVER
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="TEST_SERVER"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-test.json" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=dev" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to DEV_SERVER
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="DEV_SERVER"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-development.json" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "Using Control-M Server: $SERVER_NAME"

  validate-and-build:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      job_files: ${{ steps.find-jobs.outputs.job_files }}
      validation_results: ${{ steps.validate.outputs.results }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find job files
        id: find-jobs
        run: |
          if [[ -n "${{ github.event.inputs.job_file }}" ]]; then
            # Specific job file provided
            JOB_FILES="${{ github.event.inputs.job_file }}"
          else
            # Find all JSON files in jobs directory
            JOB_FILES=$(find jobs/ -name "*.json" -type f | tr '\n' ' ')
          fi
          echo "job_files=$JOB_FILES" >> $GITHUB_OUTPUT
          echo "Found job files: $JOB_FILES"

      - name: Validate Control-M jobs
        id: validate
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          VALIDATION_RESULTS=""
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          
          # Check if descriptor file exists
          if [[ ! -f "$DESCRIPTOR_FILE" ]]; then
            echo "Warning: Descriptor file $DESCRIPTOR_FILE not found. Using jobs without transformation."
            DESCRIPTOR_FILE=""
          fi
          
          for job_file in ${{ steps.find-jobs.outputs.job_files }}; do
            echo "Validating job file: $job_file"
            
            if [[ -n "$DESCRIPTOR_FILE" ]]; then
              # Validate with descriptor file
              RESULT=$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" "$DESCRIPTOR_FILE" 2>&1)
            else
              # Validate without descriptor file
              RESULT=$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" 2>&1)
            fi
            
            echo "Validation result for $job_file:"
            echo "$RESULT"
            
            # Check if validation failed
            if echo "$RESULT" | grep -q '"errors"'; then
              echo "❌ Validation failed for $job_file"
              echo "::error::Validation failed for $job_file: $RESULT"
              exit 1
            else
              echo "✅ Validation passed for $job_file"
            fi
            
            VALIDATION_RESULTS="$VALIDATION_RESULTS\n$job_file: PASSED"
          done
          
          echo "results=$VALIDATION_RESULTS" >> $GITHUB_OUTPUT

  transform-jobs:
    needs: [determine-environment, validate-and-build]
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Transform jobs for target environment
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          
          # Create transformed directory
          mkdir -p transformed-jobs
          
          for job_file in ${{ needs.validate-and-build.outputs.job_files }}; do
            echo "========================================"
            echo "Transforming job file: $job_file"
            echo "========================================"
            
            base_name=$(basename "$job_file" .json)
            transformed_file="transformed-jobs/${base_name}-transformed.json"
            
            if [[ -f "$DESCRIPTOR_FILE" ]]; then
              echo "Using descriptor file: $DESCRIPTOR_FILE"
              echo "Descriptor file contents:"
              cat "$DESCRIPTOR_FILE"
              echo ""
              echo "Original job file contents:"
              cat "$job_file"
              echo ""
              
              # Transform with descriptor file - extract only the last JSON block
              echo "Running: ctm deploy transform $job_file $DESCRIPTOR_FILE"
              docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm deploy transform "$job_file" "$DESCRIPTOR_FILE" > temp_transform_output.txt
              
              TRANSFORM_EXIT_CODE=$?
              echo "Transform exit code: $TRANSFORM_EXIT_CODE"
              
              # Extract only the actual transformed JSON (the last complete JSON block)
              if [[ $TRANSFORM_EXIT_CODE -eq 0 ]] && [[ -s temp_transform_output.txt ]]; then
                # Find the line number of the last occurrence of a line starting with '{'
                # This should be the actual transformed JSON, not the CLI banner
                LAST_JSON_LINE=$(grep -n "^{" temp_transform_output.txt | tail -1 | cut -d: -f1)
                
                if [[ -n "$LAST_JSON_LINE" ]]; then
                  echo "Extracting JSON starting from line $LAST_JSON_LINE"
                  tail -n +$LAST_JSON_LINE temp_transform_output.txt > "$transformed_file"
                else
                  echo "❌ No JSON block found in transform output!"
                  echo "Full transform output:"
                  cat temp_transform_output.txt
                  rm temp_transform_output.txt
                  exit 1
                fi
                
                # Clean up temp file
                rm temp_transform_output.txt
                
                echo "Transform output file size: $(wc -c < "$transformed_file" || echo "0") bytes"
                
                if [[ -s "$transformed_file" ]]; then
                  echo "Extracted JSON content (first 10 lines):"
                  head -10 "$transformed_file"
                  echo ""
                else
                  echo "❌ No JSON content extracted!"
                  exit 1
                fi
              else
                echo "❌ Transform command failed or produced no output"
                if [[ -f temp_transform_output.txt ]]; then
                  echo "Transform output:"
                  cat temp_transform_output.txt
                  rm temp_transform_output.txt
                fi
                exit 1
              fi
              
              # Validate JSON
              if jq empty "$transformed_file" 2>/dev/null; then
                echo "✅ Transformation successful - valid JSON produced"
              else
                echo "❌ Transformation failed - invalid JSON produced"
                echo "Raw file contents:"
                cat "$transformed_file"
                exit 1
              fi
            else
              echo "❌ Descriptor file not found: $DESCRIPTOR_FILE"
              echo "Available files in deploy-descriptors/:"
              ls -la deploy-descriptors/ || echo "deploy-descriptors directory not found"
              echo "Using original job file without transformation"
              cp "$job_file" "$transformed_file"
            fi
            
            echo "Final transformed job saved to: $transformed_file"
            echo ""
          done

      - name: Upload transformed jobs
        uses: actions/upload-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/
          retention-days: 30

  deploy-jobs:
    needs: [determine-environment, validate-and-build, transform-jobs]
    runs-on: ubuntu-latest
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    outputs:
      deployed_folders: ${{ steps.deploy.outputs.deployed_folders }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download transformed jobs
        uses: actions/download-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/

      - name: Deploy jobs to Control-M
        id: deploy
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          DEPLOYED_FOLDERS=""
          
          # Enable verbose logging
          set -x
          
          for transformed_file in transformed-jobs/*-transformed.json; do
            echo "========================================"
            echo "Deploying job file: $transformed_file"
            echo "========================================"
            
            # Show file contents for debugging
            echo "File contents:"
            cat "$transformed_file"
            echo ""
            echo "========================================"
            
            # Run deployment with more verbose output
            echo "Running Control-M deployment command..."
            RESULT=$(docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -e CTM_ENV_NAME="$CTM_ENV_NAME" \
              -v "$PWD:/workspace" \
              -w /workspace \
              ${{ env.DOCKER_IMAGE }} \
              bash -c "echo 'Container environment:' && env | grep CTM && echo 'Running deploy command:' && ctm deploy '$transformed_file'" 2>&1)
            
            EXIT_CODE=$?
            echo "Docker exit code: $EXIT_CODE"
            echo "========================================"
            echo "Full deployment result for $transformed_file:"
            echo "$RESULT"
            echo "========================================"
            
            # Check if deployment failed - look for both errors and exit code
            if [[ $EXIT_CODE -ne 0 ]] || echo "$RESULT" | grep -q '"errors"'; then
              echo "❌ Deployment failed for $transformed_file"
              echo "Exit code: $EXIT_CODE"
              if echo "$RESULT" | grep -q '"errors"'; then
                echo "Error details:"
                echo "$RESULT" | jq '.errors' 2>/dev/null || echo "$RESULT"
              fi
              echo "::error::Deployment failed for $transformed_file with exit code $EXIT_CODE: $RESULT"
              exit 1
            else
              echo "✅ Deployment succeeded for $transformed_file"
              
              # Extract deployed folders from result - improved parsing
              echo "Parsing deployment result for folders..."
              
              # Method 1: Try to extract from JSON array format
              FOLDERS=$(echo "$RESULT" | jq -r 'if type == "array" then .[0].deployedFolders[]? else .deployedFolders[]? end' 2>/dev/null || echo "")
              
              # Method 2: If that fails, try extracting from simple object
              if [[ -z "$FOLDERS" ]]; then
                FOLDERS=$(echo "$RESULT" | jq -r '.deployedFolders[]?' 2>/dev/null || echo "")
              fi
              
              # Method 3: If still no luck, try grep-based extraction
              if [[ -z "$FOLDERS" ]]; then
                FOLDERS=$(echo "$RESULT" | grep -oP '"deployedFolders":\s*\[\s*"\K[^"]*' 2>/dev/null || echo "")
              fi
              
              # Method 4: Look for any folder-like patterns in the output
              if [[ -z "$FOLDERS" ]]; then
                echo "Trying pattern-based folder extraction..."
                FOLDERS=$(echo "$RESULT" | grep -oP '[a-zA-Z0-9]+-[a-zA-Z0-9]+-[a-zA-Z0-9]+' 2>/dev/null | head -1 || echo "")
              fi
              
              if [[ -n "$FOLDERS" ]]; then
                DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $FOLDERS"
                echo "Extracted folders: $FOLDERS"
                echo "Total deployed folders so far: $DEPLOYED_FOLDERS"
              else
                echo "⚠️ No deployedFolders found in result"
                echo "Full result for debugging:"
                echo "$RESULT" | head -50
                
                # As fallback, try to extract folder name from job file
                JOB_FOLDER=$(basename "$transformed_file" .json | sed 's/-transformed$//')
                echo "Using fallback folder name: $JOB_FOLDER"
                DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $JOB_FOLDER"
              fi
            fi
            echo ""
          done
          
          echo "deployed_folders=$DEPLOYED_FOLDERS" >> $GITHUB_OUTPUT
          echo "Successfully deployed folders: $DEPLOYED_FOLDERS"

  run-jobs:
    needs: [determine-environment, deploy-jobs]
    runs-on: ubuntu-latest
    if: success() && needs.deploy-jobs.outputs.deployed_folders != '' && (github.event.inputs.run_jobs == 'true' || github.ref == 'refs/heads/main')
    steps:
      - name: Debug configuration
        run: |
          echo "Server name: ${{ needs.determine-environment.outputs.ctm_server_name }}"
          echo "Environment name: ${{ needs.determine-environment.outputs.ctm_env_name }}"
          echo "Endpoint: ${{ needs.determine-environment.outputs.ctm_endpoint }}"
          echo "Deployed folders: '${{ needs.deploy-jobs.outputs.deployed_folders }}'"
          
      - name: Run deployed Control-M jobs
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
          CTM_SERVER_NAME: ${{ needs.determine-environment.outputs.ctm_server_name }}
        run: |
          FOLDERS="${{ needs.deploy-jobs.outputs.deployed_folders }}"
          
          if [[ -z "$FOLDERS" || "$FOLDERS" == " " ]]; then
            echo "❌ No deployed folders to run"
            exit 1
          fi
          
          # Split folders by space and process each
          IFS=' ' read -ra FOLDER_ARRAY <<< "$FOLDERS"
          
          for folder in "${FOLDER_ARRAY[@]}"; do
            # Skip empty folder names
            if [[ -z "$folder" ]]; then
              continue
            fi
            
            echo "===========================================" 
            echo "Running folder: '$folder' on server: '$CTM_SERVER_NAME'"
            echo "==========================================="
            
            # Order the job/folder using the correct server name
            echo "Executing: ctm run order '$CTM_SERVER_NAME' '$folder'"
            
            RUN_RESULT=$(docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -e CTM_ENV_NAME="$CTM_ENV_NAME" \
              ${{ env.DOCKER_IMAGE }} \
              ctm run order "$CTM_SERVER_NAME" "$folder" 2>&1)
            
            RUN_EXIT_CODE=$?
            echo "Run command exit code: $RUN_EXIT_CODE"
            echo "Run result for $folder:"
            echo "$RUN_RESULT"
            
            if [[ $RUN_EXIT_CODE -ne 0 ]]; then
              echo "❌ Failed to start job execution for folder: $folder"
              echo "::error::Failed to start job execution for folder: $folder - Exit code: $RUN_EXIT_CODE"
              
              # Check if it's a server name issue
              if echo "$RUN_RESULT" | grep -i "server.*not found\|invalid.*server\|unknown.*server"; then
                echo "::error::Server name '$CTM_SERVER_NAME' may be incorrect. Please verify the Control-M server name."
              fi
              continue
            fi
            
            # Extract run ID with better parsing
            RUN_ID=$(echo "$RUN_RESULT" | jq -r '.runId // empty' 2>/dev/null)
            
            if [[ -n "$RUN_ID" && "$RUN_ID" != "null" ]]; then
              echo "✅ Started job execution with Run ID: $RUN_ID"
              
              # Wait and check status
              echo "Waiting 30 seconds before checking status..."
              sleep 30
              
              for attempt in {1..5}; do
                echo "Status check attempt $attempt/5..."
                
                STATUS_RESULT=$(docker run --rm \
                  -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                  -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                  -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                  ${{ env.DOCKER_IMAGE }} \
                  ctm run status "$RUN_ID" 2>&1)
                
                STATUS_EXIT_CODE=$?
                echo "Status command exit code: $STATUS_EXIT_CODE"
                
                if [[ $STATUS_EXIT_CODE -eq 0 ]]; then
                  echo "Status for Run ID $RUN_ID:"
                  echo "$STATUS_RESULT"
                  
                  # Check completion status
                  COMPLETION=$(echo "$STATUS_RESULT" | jq -r '.completion // empty' 2>/dev/null)
                  STATUS_STATE=$(echo "$STATUS_RESULT" | jq -r '.status // empty' 2>/dev/null)
                  
                  echo "Completion: '$COMPLETION', Status: '$STATUS_STATE'"
                  
                  if [[ "$COMPLETION" == "Completed" ]]; then
                    echo "✅ Job execution completed successfully for folder: $folder"
                    break
                  elif [[ "$STATUS_STATE" == "Running" || "$STATUS_STATE" == "Executing" ]]; then
                    echo "⏳ Job execution in progress for folder: $folder"
                    if [[ $attempt -lt 5 ]]; then
                      echo "Waiting 60 seconds before next check..."
                      sleep 60
                    fi
                  elif [[ "$STATUS_STATE" == "Ended OK" || "$COMPLETION" == "OK" ]]; then
                    echo "✅ Job execution ended successfully for folder: $folder"
                    break
                  else
                    echo "ℹ️ Job status: '$STATUS_STATE', Completion: '$COMPLETION' for folder: $folder"
                    if [[ $attempt -lt 5 ]]; then
                      sleep 30
                    fi
                  fi
                else
                  echo "⚠️ Status check failed for Run ID $RUN_ID (attempt $attempt/5)"
                  echo "$STATUS_RESULT"
                  if [[ $attempt -lt 5 ]]; then
                    sleep 15
                  fi
                fi
              done
            else
              echo "❌ Failed to extract Run ID from result for folder: $folder"
              echo "Raw run result:"
              echo "$RUN_RESULT"
              
              # Check if the job was actually ordered but response format is different
              if echo "$RUN_RESULT" | grep -i "ordered\|submitted\|started"; then
                echo "ℹ️ Job may have been ordered successfully despite missing Run ID"
              fi
            fi
            
            echo ""
          done

  notify:
    needs: [determine-environment, validate-and-build, deploy-jobs, run-jobs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Create deployment summary
        run: |
          echo "## Control-M Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** ${{ needs.determine-environment.outputs.ctm_server_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoint:** ${{ needs.determine-environment.outputs.ctm_endpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.validate-and-build.result }}" == "success" ]]; then
            echo "✅ **Validation:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Validation:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-jobs.result }}" == "success" ]]; then
            echo "✅ **Deployment:** Succeeded" >> $GITHUB_STEP_SUMMARY
            echo "**Deployed Folders:** ${{ needs.deploy-jobs.outputs.deployed_folders }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-jobs.result }}" == "skipped" ]]; then
            echo "⏭️ **Deployment:** Skipped (not main/develop branch)" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.run-jobs.result }}" == "success" ]]; then
            echo "✅ **Job Execution:** Completed" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.run-jobs.result }}" == "skipped" ]]; then
            echo "⏭️ **Job Execution:** Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Job Execution:** Failed" >> $GITHUB_STEP_SUMMARY
          fi