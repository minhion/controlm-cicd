name: Control-M Job Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - test
          - production
      server_name:
        description: 'Control-M Server Name (e.g., IN01, TEST_SERVER)'
        required: false
        type: string
        default: ''
      job_file:
        description: 'Specific job file to deploy (optional)'
        required: false
        type: string
      run_jobs:
        description: 'Run jobs after deployment'
        required: false
        default: false
        type: boolean

env:
  DOCKER_IMAGE: minhion/controlm-cli:22

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      target_env: ${{ steps.set-env.outputs.target_env }}
      ctm_endpoint: ${{ steps.set-env.outputs.ctm_endpoint }}
      ctm_env_name: ${{ steps.set-env.outputs.ctm_env_name }}
      ctm_server_name: ${{ steps.set-env.outputs.ctm_server_name }}
      descriptor_file: ${{ steps.set-env.outputs.descriptor_file }}
    steps:
      - name: Determine target environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TARGET_ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TARGET_ENV="test"
          else
            TARGET_ENV="development"
          fi
          
          echo "target_env=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "Target environment: $TARGET_ENV"
          
          # Set environment-specific variables including server names
          case $TARGET_ENV in
            "production")
              echo "ctm_endpoint=https://se-prod-aapi.us1.controlm.com/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=prod" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to IN01
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="IN01"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-production.json" >> $GITHUB_OUTPUT
              ;;
            "test")
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=test" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to TEST_SERVER
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="TEST_SERVER"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-test.json" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=dev" >> $GITHUB_OUTPUT
              # Use input server name if provided, otherwise default to DEV_SERVER
              SERVER_NAME="${{ github.event.inputs.server_name }}"
              if [[ -z "$SERVER_NAME" ]]; then
                SERVER_NAME="DEV_SERVER"
              fi
              echo "ctm_server_name=$SERVER_NAME" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-development.json" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "Using Control-M Server: $SERVER_NAME"

  validate-and-build:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      job_files: ${{ steps.find-jobs.outputs.job_files }}
      validation_results: ${{ steps.validate.outputs.results }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find job files
        id: find-jobs
        run: |
          if [[ -n "${{ github.event.inputs.job_file }}" ]]; then
            # Specific job file provided
            JOB_FILES="${{ github.event.inputs.job_file }}"
          else
            # Find all JSON files in jobs directory
            JOB_FILES=$(find jobs/ -name "*.json" -type f | tr '\n' ' ')
          fi
          echo "job_files=$JOB_FILES" >> $GITHUB_OUTPUT
          echo "Found job files: $JOB_FILES"

      - name: Validate Control-M jobs
        id: validate
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          VALIDATION_RESULTS=""
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          
          # Check if descriptor file exists
          if [[ ! -f "$DESCRIPTOR_FILE" ]]; then
            echo "Warning: Descriptor file $DESCRIPTOR_FILE not found. Using jobs without transformation."
            DESCRIPTOR_FILE=""
          fi
          
          for job_file in ${{ steps.find-jobs.outputs.job_files }}; do
            echo "Validating job file: $job_file"
            
            if [[ -n "$DESCRIPTOR_FILE" ]]; then
              # Validate with descriptor file
              RESULT=$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" "$DESCRIPTOR_FILE" 2>&1)
            else
              # Validate without descriptor file
              RESULT=$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" 2>&1)
            fi
            
            echo "Validation result for $job_file:"
            echo "$RESULT"
            
            # Check if validation failed
            if echo "$RESULT" | grep -q '"errors"'; then
              echo "❌ Validation failed for $job_file"
              echo "::error::Validation failed for $job_file: $RESULT"
              exit 1
            else
              echo "✅ Validation passed for $job_file"
            fi
            
            VALIDATION_RESULTS="$VALIDATION_RESULTS\n$job_file: PASSED"
          done
          
          echo "results=$VALIDATION_RESULTS" >> $GITHUB_OUTPUT

  transform-jobs:
    needs: [determine-environment, validate-and-build]
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Transform jobs for target environment
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          
          # Create transformed directory
          mkdir -p transformed-jobs
          
          for job_file in ${{ needs.validate-and-build.outputs.job_files }}; do
            echo "========================================"
            echo "Transforming job file: $job_file"
            echo "========================================"
            
            base_name=$(basename "$job_file" .json)
            transformed_file="transformed-jobs/${base_name}-transformed.json"
            
            if [[ -f "$DESCRIPTOR_FILE" ]]; then
              echo "Using descriptor file: $DESCRIPTOR_FILE"
              echo "Descriptor file contents:"
              cat "$DESCRIPTOR_FILE"
              echo ""
              echo "Original job file contents:"
              cat "$job_file"
              echo ""
              
              # Transform with descriptor file - extract only the last JSON block
              echo "Running: ctm deploy transform $job_file $DESCRIPTOR_FILE"
              docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$PWD:/workspace" \
                -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm deploy transform "$job_file" "$DESCRIPTOR_FILE" > temp_transform_output.txt
              
              TRANSFORM_EXIT_CODE=$?
              echo "Transform exit code: $TRANSFORM_EXIT_CODE"
              
              # Extract only the actual transformed JSON (the last complete JSON block)
              if [[ $TRANSFORM_EXIT_CODE -eq 0 ]] && [[ -s temp_transform_output.txt ]]; then
                # Find the line number of the last occurrence of a line starting with '{'
                # This should be the actual transformed JSON, not the CLI banner
                LAST_JSON_LINE=$(grep -n "^{" temp_transform_output.txt | tail -1 | cut -d: -f1)
                
                if [[ -n "$LAST_JSON_LINE" ]]; then
                  echo "Extracting JSON starting from line $LAST_JSON_LINE"
                  tail -n +$LAST_JSON_LINE temp_transform_output.txt > "$transformed_file"
                else
                  echo "❌ No JSON block found in transform output!"
                  echo "Full transform output:"
                  cat temp_transform_output.txt
                  rm temp_transform_output.txt
                  exit 1
                fi
                
                # Clean up temp file
                rm temp_transform_output.txt
                
                echo "Transform output file size: $(wc -c < "$transformed_file" || echo "0") bytes"
                
                if [[ -s "$transformed_file" ]]; then
                  echo "Extracted JSON content (first 10 lines):"
                  head -10 "$transformed_file"
                  echo ""
                else
                  echo "❌ No JSON content extracted!"
                  exit 1
                fi
              else
                echo "❌ Transform command failed or produced no output"
                if [[ -f temp_transform_output.txt ]]; then
                  echo "Transform output:"
                  cat temp_transform_output.txt
                  rm temp_transform_output.txt
                fi
                exit 1
              fi
              
              # Validate JSON
              if jq empty "$transformed_file" 2>/dev/null; then
                echo "✅ Transformation successful - valid JSON produced"
              else
                echo "❌ Transformation failed - invalid JSON produced"
                echo "Raw file contents:"
                cat "$transformed_file"
                exit 1
              fi
            else
              echo "❌ Descriptor file not found: $DESCRIPTOR_FILE"
              echo "Available files in deploy-descriptors/:"
              ls -la deploy-descriptors/ || echo "deploy-descriptors directory not found"
              echo "Using original job file without transformation"
              cp "$job_file" "$transformed_file"
            fi
            
            echo "Final transformed job saved to: $transformed_file"
            echo ""
          done

      - name: Upload transformed jobs
        uses: actions/upload-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/
          retention-days: 30

  deploy-jobs:
    needs: [determine-environment, validate-and-build, transform-jobs]
    runs-on: ubuntu-latest
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    outputs:
      deployed_folders: ${{ steps.deploy.outputs.deployed_folders }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download transformed jobs
        uses: actions/download-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/

      - name: Deploy jobs to Control-M
        id: deploy
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets.CTM_API_TOKEN }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        run: |
          DEPLOYED_FOLDERS=""
          
          # Enable verbose logging
          set -x
          
          for transformed_file in transformed-jobs/*-transformed.json; do
            echo "========================================"
            echo "Deploying job file: $transformed_file"
            echo "========================================"
            
            # Show file contents for debugging
            echo "File contents:"
            cat "$transformed_file"
            echo ""
            echo "========================================"
            
            # Run deployment with more verbose output
            echo "Running Control-M deployment command..."
            RESULT=$(docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -e CTM_ENV_NAME="$CTM_ENV_NAME" \
              -v "$PWD:/workspace" \
              -w /workspace \
              ${{ env.DOCKER_IMAGE }} \
              bash -c "echo 'Container environment:' && env | grep CTM && echo 'Running deploy command:' && ctm deploy '$transformed_file'" 2>&1)
            
            EXIT_CODE=$?
            echo "Docker exit code: $EXIT_CODE"
            echo "========================================"
            echo "Full deployment result for $transformed_file:"
            echo "$RESULT"
            echo "========================================"
            
            # Check if deployment failed - look for both errors and exit code
            if [[ $EXIT_CODE -ne 0 ]] || echo "$RESULT" | grep -q '"errors"'; then
              echo "❌ Deployment failed for $transformed_file"
              echo "Exit code: $EXIT_CODE"
              if echo "$RESULT" | grep -q '"errors"'; then
                echo "Error details:"
                echo "$RESULT" | jq '.errors' 2>/dev/null || echo "$RESULT"
              fi
              echo "::error::Deployment failed for $transformed_file with exit code $EXIT_CODE: $RESULT"
              exit 1
            else
              echo "✅ Deployment succeeded for $transformed_file"
              
              # Extract folder name directly from the transformed JSON file
              echo "Extracting folder name from transformed file: $transformed_file"
              
              # Extract the root-level key where the value has "Type": "Folder"
              FOLDER_NAME=$(jq -r 'to_entries | .[] | select(.value.Type == "Folder") | .key' "$transformed_file" 2>/dev/null)
              
              if [[ -n "$FOLDER_NAME" && "$FOLDER_NAME" != "null" ]]; then
                DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $FOLDER_NAME"
                echo "✅ Extracted folder name from JSON: $FOLDER_NAME"
                echo "Total deployed folders so far: $DEPLOYED_FOLDERS"
              else
                echo "⚠️ Could not extract folder name from JSON structure"
                echo "File content preview:"
                head -20 "$transformed_file"
                
                # Fallback: try to extract any root-level key (first one)
                FALLBACK_FOLDER=$(jq -r 'keys[0]' "$transformed_file" 2>/dev/null)
                if [[ -n "$FALLBACK_FOLDER" && "$FALLBACK_FOLDER" != "null" ]]; then
                  DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $FALLBACK_FOLDER"
                  echo "Using fallback folder name (first key): $FALLBACK_FOLDER"
                else
                  # Final fallback: use filename
                  JOB_FOLDER=$(basename "$transformed_file" .json | sed 's/-transformed$//')
                  echo "Using filename-based folder name: $JOB_FOLDER"
                  DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $JOB_FOLDER"
                fi
              fi
            fi
            echo ""
          done
          
          echo "deployed_folders=$DEPLOYED_FOLDERS" >> $GITHUB_OUTPUT
          echo "Successfully deployed folders: $DEPLOYED_FOLDERS"

  notify:
    needs: [determine-environment, validate-and-build, deploy-jobs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Create deployment summary
        run: |
          echo "## Control-M Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** ${{ needs.determine-environment.outputs.ctm_server_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoint:** ${{ needs.determine-environment.outputs.ctm_endpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.validate-and-build.result }}" == "success" ]]; then
            echo "✅ **Validation:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Validation:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-jobs.result }}" == "success" ]]; then
            echo "✅ **Deployment:** Succeeded" >> $GITHUB_STEP_SUMMARY
            echo "**Deployed Folders:** ${{ needs.deploy-jobs.outputs.deployed_folders }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-jobs.result }}" == "skipped" ]]; then
            echo "⭐️ **Deployment:** Skipped (not main/develop branch)" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
