name: Control-M Job Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'jobs/**'
      - 'deploy-descriptors/**'
      - 'connection-profiles/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options: [ development, test, production ]
      job_file:
        description: 'Specific job file to deploy (optional)'
        required: false
        type: string
      run_jobs:
        description: 'Run jobs after deployment'
        required: false
        default: false
        type: boolean

env:
  DOCKER_IMAGE: minhion/controlm-cli:22

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      target_env:    ${{ steps.set-env.outputs.target_env }}
      ctm_endpoint:  ${{ steps.set-env.outputs.ctm_endpoint }}
      ctm_env_name:  ${{ steps.set-env.outputs.ctm_env_name }}
      descriptor_file: ${{ steps.set-env.outputs.descriptor_file }}
      ctm_server:    ${{ steps.set-env.outputs.ctm_server }}
      token_name:    ${{ steps.set-env.outputs.token_name }}
    steps:
      - name: Determine target environment
        id: set-env
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TARGET_ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            TARGET_ENV="test"
          else
            TARGET_ENV="development"
          fi
          echo "target_env=$TARGET_ENV" >> $GITHUB_OUTPUT

          case "$TARGET_ENV" in
            "production")
              echo "ctm_endpoint=https://se-prod-aapi.us1.controlm.com/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=prod" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-production.json" >> $GITHUB_OUTPUT
              echo "ctm_server=IN01" >> $GITHUB_OUTPUT
              echo "token_name=CTM_API_TOKEN_PROD" >> $GITHUB_OUTPUT
              ;;
            "test")
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=test" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-test.json" >> $GITHUB_OUTPUT
              echo "ctm_server=IN01" >> $GITHUB_OUTPUT
              echo "token_name=CTM_API_TOKEN_TEST" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "ctm_endpoint=https://192.168.1.65:8443/automation-api" >> $GITHUB_OUTPUT
              echo "ctm_env_name=dev" >> $GITHUB_OUTPUT
              echo "descriptor_file=deploy-descriptors/descriptor-development.json" >> $GITHUB_OUTPUT
              echo "ctm_server=IN01" >> $GITHUB_OUTPUT
              echo "token_name=CTM_API_TOKEN_DEV" >> $GITHUB_OUTPUT
              ;;
          esac

  validate-and-build:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      job_files: ${{ steps.find-jobs.outputs.job_files }}
      validation_results: ${{ steps.validate.outputs.results }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to Control-M (persist ~/.ctm)
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
        run: |
          mkdir -p "$RUNNER_TEMP/.ctm"
          docker run --rm \
            -e CTM_ENDPOINT="$CTM_ENDPOINT" \
            -e CTM_API_TOKEN="$CTM_API_TOKEN" \
            -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
            ${{ env.DOCKER_IMAGE }} \
            bash -lc 'ctm login -a "$CTM_ENDPOINT" -t "$CTM_API_TOKEN"'

      - name: Find job files
        id: find-jobs
        shell: bash
        run: |
          if [[ -n "${{ github.event.inputs.job_file }}" ]]; then
            JOB_FILES="${{ github.event.inputs.job_file }}"
          else
            JOB_FILES="$(find jobs/ -type f -name '*.json' | sort | tr '\n' ' ')"
          fi
          if [[ -z "$JOB_FILES" ]]; then
            echo "No job files found under jobs/"; exit 1
          fi
          echo "job_files=$JOB_FILES" >> $GITHUB_OUTPUT
          echo "Found job files: $JOB_FILES"

      - name: Validate Control-M jobs
        id: validate
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        shell: bash
        run: |
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          if [[ -n "$DESCRIPTOR_FILE" && ! -f "$DESCRIPTOR_FILE" ]]; then
            echo "Descriptor file not found: $DESCRIPTOR_FILE"; exit 1
          fi
          RESULTS=""
          for job_file in ${{ steps.find-jobs.outputs.job_files }}; do
            echo "Validating: $job_file"
            if [[ -n "$DESCRIPTOR_FILE" ]]; then
              RESULT="$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
                -v "$PWD:/workspace" -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" "$DESCRIPTOR_FILE" 2>&1)"
            else
              RESULT="$(docker run --rm \
                -e CTM_ENDPOINT="$CTM_ENDPOINT" \
                -e CTM_API_TOKEN="$CTM_API_TOKEN" \
                -e CTM_ENV_NAME="$CTM_ENV_NAME" \
                -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
                -v "$PWD:/workspace" -w /workspace \
                ${{ env.DOCKER_IMAGE }} \
                ctm build "$job_file" 2>&1)"
            fi
            echo "$RESULT"
            if echo "$RESULT" | grep -q '"errors"'; then
              echo "::error::Validation failed for $job_file"; exit 1
            fi
            RESULTS="$RESULTS\n$job_file: PASSED"
          done
          echo "results=$RESULTS" >> $GITHUB_OUTPUT

  transform-jobs:
    needs: [determine-environment, validate-and-build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Login to Control-M (persist ~/.ctm)
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
        run: |
          mkdir -p "$RUNNER_TEMP/.ctm"
          docker run --rm \
            -e CTM_ENDPOINT="$CTM_ENDPOINT" \
            -e CTM_API_TOKEN="$CTM_API_TOKEN" \
            -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
            ${{ env.DOCKER_IMAGE }} \
            bash -lc 'ctm login -a "$CTM_ENDPOINT" -t "$CTM_API_TOKEN"'

      - name: Transform jobs for target environment
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        shell: bash
        run: |
          DESCRIPTOR_FILE="${{ needs.determine-environment.outputs.descriptor_file }}"
          mkdir -p transformed-jobs
          for job_file in ${{ needs.validate-and-build.outputs.job_files }}; do
            base="$(basename "$job_file" .json)"
            out="transformed-jobs/${base}-transformed.json"
            echo "Transforming: $job_file  ->  $out"
            docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -e CTM_ENV_NAME="$CTM_ENV_NAME" \
              -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
              -v "$PWD:/workspace" -w /workspace \
              ${{ env.DOCKER_IMAGE }} \
              ctm deploy transform "$job_file" "$DESCRIPTOR_FILE" > _tmp_transform.txt
            code=$?
            if [[ $code -ne 0 || ! -s _tmp_transform.txt ]]; then
              echo "Transform failed or produced no output"; exit 1
            fi
            # Keep the LAST JSON block to avoid any banner lines
            start_line="$(grep -n '{' _tmp_transform.txt | tail -1 | cut -d: -f1 || echo 0)"
            if [[ "$start_line" -gt 0 ]]; then
              tail -n +"$start_line" _tmp_transform.txt > "$out"
            else
              echo "Could not locate JSON in transform output"; exit 1
            fi
            rm -f _tmp_transform.txt
            # Sanity check it's valid JSON
            if ! jq empty "$out" >/dev/null 2>&1; then
              echo "Invalid JSON produced by transform for $job_file"; exit 1
            fi
          done

      - name: Upload transformed jobs
        uses: actions/upload-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/
          retention-days: 30

  deploy-jobs:
    needs: [determine-environment, validate-and-build, transform-jobs]
    runs-on: ubuntu-latest
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    outputs:
      deployed_folders: ${{ steps.deploy.outputs.deployed_folders }}
    steps:
      - uses: actions/checkout@v4

      - name: Ensure jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Login to Control-M (persist ~/.ctm)
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
        run: |
          mkdir -p "$RUNNER_TEMP/.ctm"
          docker run --rm \
            -e CTM_ENDPOINT="$CTM_ENDPOINT" \
            -e CTM_API_TOKEN="$CTM_API_TOKEN" \
            -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
            ${{ env.DOCKER_IMAGE }} \
            bash -lc 'ctm login -a "$CTM_ENDPOINT" -t "$CTM_API_TOKEN"'

      - name: Download transformed jobs
        uses: actions/download-artifact@v4
        with:
          name: transformed-jobs-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/

      - name: Deploy jobs to Control-M
        id: deploy
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
        shell: bash
        run: |
          DEPLOYED_FOLDERS=""
          shopt -s nullglob
          for tf in transformed-jobs/*-transformed.json; do
            echo "Deploying: $tf"
            RESULT="$(docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -e CTM_ENV_NAME="$CTM_ENV_NAME" \
              -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
              -v "$PWD:/workspace" -w /workspace \
              ${{ env.DOCKER_IMAGE }} \
              bash -lc 'ctm deploy "'"$tf"'"' 2>&1)"
            echo "$RESULT"
            if echo "$RESULT" | grep -q '"errors"'; then
              echo "::error::Deployment failed for $tf"; exit 1
            fi
            # Extract deployed folders if present
            FOLDERS="$(echo "$RESULT" | jq -r '.[].deployedFolders[]?' 2>/dev/null || true)"
            if [[ -n "$FOLDERS" ]]; then
              DEPLOYED_FOLDERS="$DEPLOYED_FOLDERS $FOLDERS"
            fi
          done
          echo "deployed_folders=$DEPLOYED_FOLDERS" >> $GITHUB_OUTPUT
          echo "Deployed folders: $DEPLOYED_FOLDERS"

      - name: Upload deploy receipts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-receipts-${{ needs.determine-environment.outputs.target_env }}
          path: transformed-jobs/*-transformed.json

  run-jobs:
    needs: [determine-environment, deploy-jobs]
    runs-on: ubuntu-latest
    if: success() && (github.event.inputs.run_jobs == 'true' || github.ref == 'refs/heads/main')
    steps:
      - name: Ensure jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Login to Control-M (persist ~/.ctm)
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
        run: |
          mkdir -p "$RUNNER_TEMP/.ctm"
          docker run --rm \
            -e CTM_ENDPOINT="$CTM_ENDPOINT" \
            -e CTM_API_TOKEN="$CTM_API_TOKEN" \
            -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
            ${{ env.DOCKER_IMAGE }} \
            bash -lc 'ctm login -a "$CTM_ENDPOINT" -t "$CTM_API_TOKEN"'

      - name: Order, wait, and fetch outputs
        env:
          CTM_ENDPOINT: ${{ needs.determine-environment.outputs.ctm_endpoint }}
          CTM_API_TOKEN: ${{ secrets[needs.determine-environment.outputs.token_name] }}
          CTM_ENV_NAME: ${{ needs.determine-environment.outputs.ctm_env_name }}
          CTM_SERVER:   ${{ needs.determine-environment.outputs.ctm_server }}
        shell: bash
        run: |
          mkdir -p _ctm_output
          for folder in ${{ needs.deploy-jobs.outputs.deployed_folders }}; do
            [[ -z "$folder" ]] && continue
            echo "Ordering folder '$folder' on server '$CTM_SERVER'"
            ORDER_JSON="$(docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
              ${{ env.DOCKER_IMAGE }} \
              bash -lc 'ctm run order "'"$CTM_SERVER"'" "'"$folder"'"')"
            echo "$ORDER_JSON"
            RUN_ID="$(printf "%s" "$ORDER_JSON" | sed -n 's/.*"runId"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')"
            if [[ -z "$RUN_ID" ]]; then
              echo "::error::Could not parse runId for $folder"; exit 1
            fi
            docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
              ${{ env.DOCKER_IMAGE }} \
              bash -lc 'ctm run status "'"$RUN_ID"'" --wait'
            safe_folder="$(echo "$folder" | tr '/ ' '__')"
            docker run --rm \
              -e CTM_ENDPOINT="$CTM_ENDPOINT" \
              -e CTM_API_TOKEN="$CTM_API_TOKEN" \
              -v "$RUNNER_TEMP/.ctm:/root/.ctm" \
              -v "$PWD:/workspace" -w /workspace \
              ${{ env.DOCKER_IMAGE }} \
              bash -lc 'ctm run results "'"$RUN_ID"'" --output-dir "/workspace/_ctm_output/'"$safe_folder"'"'
          done

      - name: Upload run outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run-outputs-${{ needs.determine-environment.outputs.target_env }}
          path: _ctm_output/**

  notify:
    needs: [determine-environment, validate-and-build, deploy-jobs, run-jobs]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "## Control-M Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoint:** ${{ needs.determine-environment.outputs.ctm_endpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** ${{ needs.determine-environment.outputs.ctm_server }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Validation: **${{ needs.validate-and-build.result }}**" >> $GITHUB_STEP_SUMMARY
          echo "Deployment: **${{ needs.deploy-jobs.result }}**" >> $GITHUB_STEP_SUMMARY
          echo "Run Jobs: **${{ needs.run-jobs.result }}**" >> $GITHUB_STEP_SUMMARY
